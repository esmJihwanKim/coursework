$date
	Sat Mar 25 17:32:00 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module test $end
$var wire 8 ! y [7:0] $end
$var wire 2 " opOut [1:0] $end
$var reg 8 # a [7:0] $end
$var reg 8 $ b [7:0] $end
$var reg 1 % clock $end
$var reg 2 & opcode [1:0] $end
$var reg 1 ' resetn $end
$var reg 3 ( shift_num [2:0] $end
$scope module u_alu $end
$var wire 1 % clock $end
$var wire 8 ) opA [7:0] $end
$var wire 8 * opB [7:0] $end
$var wire 2 + opcode [1:0] $end
$var wire 1 ' resetn $end
$var wire 3 , shift_num [2:0] $end
$var wire 8 - y [7:0] $end
$var wire 8 . sum [7:0] $end
$var wire 8 / sub [7:0] $end
$var wire 8 0 shift [7:0] $end
$var wire 1 1 left_right $end
$var reg 2 2 opOut [1:0] $end
$scope module u_adder $end
$var wire 8 3 a [7:0] $end
$var wire 8 4 b [7:0] $end
$var wire 1 % clock $end
$var wire 1 ' resetn $end
$var reg 8 5 sum [7:0] $end
$var reg 8 6 y [7:0] $end
$upscope $end
$scope module u_mux $end
$var wire 8 7 in0 [7:0] $end
$var wire 2 8 sel [1:0] $end
$var wire 8 9 in3 [7:0] $end
$var wire 8 : in2 [7:0] $end
$var wire 8 ; in1 [7:0] $end
$var reg 8 < out [7:0] $end
$upscope $end
$scope module u_shift $end
$var wire 8 = a [7:0] $end
$var wire 1 % clock $end
$var wire 1 1 left_right $end
$var wire 3 > num [2:0] $end
$var wire 1 ' resetn $end
$var reg 8 ? result [7:0] $end
$var reg 8 @ y [7:0] $end
$scope task shifter $end
$var reg 8 A a [7:0] $end
$var reg 1 B left_right $end
$var reg 3 C num [2:0] $end
$var reg 8 D y [7:0] $end
$upscope $end
$upscope $end
$scope module u_sub $end
$var wire 8 E a [7:0] $end
$var wire 8 F b [7:0] $end
$var wire 1 % clock $end
$var wire 1 G en $end
$var wire 1 ' resetn $end
$var reg 8 H y [7:0] $end
$scope function sub $end
$var reg 8 I a [7:0] $end
$var reg 8 J b [7:0] $end
$var reg 8 K sub [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx K
bx J
bx I
b0 H
1G
bx F
bx E
bx D
bx C
xB
bx A
b0 @
bx ?
bx >
bx =
b0 <
b0 ;
b0 :
b0 9
b0 8
b0 7
b0 6
bx 5
bx 4
bx 3
b0 2
x1
b0 0
b0 /
b0 .
b0 -
bx ,
bx +
bx *
bx )
bx (
0'
bx &
0%
bx $
bx #
b0 "
b0 !
$end
#10
1%
#20
0%
#30
1%
#40
0%
#50
1%
#60
0%
#70
1%
#80
0%
#90
1%
#100
1'
0%
#110
b11 5
01
bx .
bx 6
bx 7
bx /
bx ;
bx H
bx "
bx 2
bx 8
b10 $
b10 *
b10 4
b10 F
b1 #
b1 )
b1 3
b1 =
b1 E
b0 &
b0 +
1%
#111
bx 0
bx 9
bx :
bx @
#120
0%
#130
b11 !
b11 -
b11 <
b100 5
11
b0 "
b0 2
b0 8
b11111111 /
b11111111 ;
b11111111 H
b11 .
b11 6
b11 7
b1 $
b1 *
b1 4
b1 F
b11 #
b11 )
b11 3
b11 =
b11 E
b1 &
b1 +
b11111111 K
b1 I
b10 J
0B
b1 A
1%
#140
0%
#150
bx !
bx -
bx <
b100 .
b100 6
b100 7
b10 /
b10 ;
b10 H
b11 "
b11 2
b11 8
b10 (
b10 ,
b10 >
b10 K
b11 I
b1 J
1B
b11 A
b11 &
b11 +
1%
#160
0%
#170
01
b101 5
b1 (
b1 ,
b1 >
b10 &
b10 +
b100 #
b100 )
b100 3
b100 =
b100 E
b10 C
1%
#171
b1100 !
b1100 -
b1100 <
b1100 0
b1100 9
b1100 :
b1100 @
b1100 ?
b1100 D
#180
0%
#190
b101 .
b101 6
b101 7
b11 /
b11 ;
b11 H
b10 "
b10 2
b10 8
b11 K
b100 I
0B
b1 C
b100 A
1%
#191
b10 !
b10 -
b10 <
b10 0
b10 9
b10 :
b10 @
b10 ?
b10 D
#200
0%
#210
1%
#220
0%
#230
1%
#240
0%
#250
1%
#260
0%
#270
1%
#280
0%
#290
1%
